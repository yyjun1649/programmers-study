# 추석 트래픽
## 문제 설명
추석 트래픽
이번 추석에도 시스템 장애가 없는 명절을 보내고 싶은 어피치는 서버를 증설해야 할지 고민이다. 장애 대비용 서버 증설 여부를 결정하기 위해 작년 추석 기간인 9월 15일 로그 데이터를 분석한 후 초당 최대 처리량을 계산해보기로 했다. 초당 최대 처리량은 요청의 응답 완료 여부에 관계없이 임의 시간부터 1초(=1,000밀리초)간 처리하는 요청의 최대 개수를 의미한다.

## 입력 형식
solution 함수에 전달되는 lines 배열은 N(1 ≦ N ≦ 2,000)개의 로그 문자열로 되어 있으며, 각 로그 문자열마다 요청에 대한 응답완료시간 S와 처리시간 T가 공백으로 구분되어 있다.
응답완료시간 S는 작년 추석인 2016년 9월 15일만 포함하여 고정 길이 2016-09-15 hh:mm:ss.sss 형식으로 되어 있다.
처리시간 T는 0.1s, 0.312s, 2s 와 같이 최대 소수점 셋째 자리까지 기록하며 뒤에는 초 단위를 의미하는 s로 끝난다.
예를 들어, 로그 문자열 2016-09-15 03:10:33.020 0.011s은 "2016년 9월 15일 오전 3시 10분 33.010초"부터 "2016년 9월 15일 오전 3시 10분 33.020초"까지 "0.011초" 동안 처리된 요청을 의미한다. (처리시간은 시작시간과 끝시간을 포함)
서버에는 타임아웃이 3초로 적용되어 있기 때문에 처리시간은 0.001 ≦ T ≦ 3.000이다.
lines 배열은 응답완료시간 S를 기준으로 오름차순 정렬되어 있다.
## 출력 형식
solution 함수에서는 로그 데이터 lines 배열에 대해 초당 최대 처리량을 리턴한다.
## 입출력 예제
```
예제1
입력: [
"2016-09-15 01:00:04.001 2.0s",
"2016-09-15 01:00:07.000 2s"
]

출력: 1

예제2
입력: [
"2016-09-15 01:00:04.002 2.0s",
"2016-09-15 01:00:07.000 2s"
]

출력: 2

설명: 처리시간은 시작시간과 끝시간을 포함하므로
첫 번째 로그는 01:00:02.003 ~ 01:00:04.002에서 2초 동안 처리되었으며,
두 번째 로그는 01:00:05.001 ~ 01:00:07.000에서 2초 동안 처리된다.
따라서, 첫 번째 로그가 끝나는 시점과 두 번째 로그가 시작하는 시점의 구간인 01:00:04.002 ~ 01:00:05.001 1초 동안 최대 2개가 된다.

예제3
입력: [
"2016-09-15 20:59:57.421 0.351s",
"2016-09-15 20:59:58.233 1.181s",
"2016-09-15 20:59:58.299 0.8s",
"2016-09-15 20:59:58.688 1.041s",
"2016-09-15 20:59:59.591 1.412s",
"2016-09-15 21:00:00.464 1.466s",
"2016-09-15 21:00:00.741 1.581s",
"2016-09-15 21:00:00.748 2.31s",
"2016-09-15 21:00:00.966 0.381s",
"2016-09-15 21:00:02.066 2.62s"
]

출력: 7

```

## 풀이
초당 최대 처리량은 임의 시간으로 부터 1초동안 완료 여부와 상관없이 처리되고 있는 작업의 갯수를 의미한다.  
즉 특정 시각으로부터 1초동안 작업되고 있는 작업의 갯수를 찾으면 된다.  


그럼 이 문제는 각각의 작업에 대하여 작업의 시작점과 끝나는 점을 찾으면 된다.  
끝나는 점엔 입력으로 주어지니 끝나는 점과 처리시간을 이용하여 시작점을 찾는다.  
나는 계산의 용이함을 위해서 밀리초단위로 변형하여 계산하였다.  


각각의 작업에 대하여 시작점과 끝점을 담는 클래스를 만들어 정보를 보관한다.  
그 후 각각의 작업 클래스에 대하여 시작점 기준으로 1초동안 처리할 수 있는 작업의 갯수를 세고
끝점을 기준으로 1초동안 처리할 수 있는 작업의 갯수를 세는 것을 모든 작업에 반복하여  
최댓값을 답으로 리턴한다.

## 코드
```

class Solution {
    
    static class Request{
        int start, end;
        
        Request(int start, int end){
            this.start =start;
            this.end = end;
        }
        
        Boolean isIn(int t1, int t2){
            if(start <= t2 && end >= t1)
                return true;
            else
                return false;
        }
    }
    
    public int solution(String[] lines) {
        int answer = 0;
        Request[] req = new Request[lines.length];
        int idx = 0;
        for(String s : lines){
            String[] token = s.split(" ");
            
            int end = convertEndTimeToMilSec(token[1]);
            int processing = convertProcessTimeToMilSec(token[2]);
            int start = end - processing + 1;
            
            req[idx++] = new Request(start, end);
        }
        
        for(Request r : req){
            int cnt1 = 0;
            int cnt2 = 0;
            for(int i = 0; i < req.length; i++){
                if(req[i].isIn(r.start, r.start+999))
                    cnt1++;
                if(req[i].isIn(r.end, r.end+999))
                    cnt2++;
            }
            answer = Math.max(answer,Math.max(cnt1, cnt2));
        }
        
        return answer;
    }
    
    static int convertProcessTimeToMilSec(String s){
        s = s.substring(0,s.length()-1);
        int ret = 0;
        
        String[] times = s.split("\\.");
        ret = Integer.parseInt(times[0]) * 1000;
        if(times.length == 2)
            ret += Integer.parseInt(times[1]);
       
        return ret;
    }
    
    static int convertEndTimeToMilSec(String s){
        String[] times = s.split(":");
            int end = 0;
            
            // hour to min
            end += Integer.parseInt(times[0]) * 60;
            
            // min to sec
            end = (end + Integer.parseInt(times[1])) * 60;
            
            // min to mmin
            String[] sec = times[2].split("\\.");

            end = (end + Integer.parseInt(sec[0])) * 1000;
            end += Integer.parseInt(sec[1]);
        return end;
    }
}


```
